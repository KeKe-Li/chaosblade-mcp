import yaml
import logging
from typing import Dict, List, Any, Optional
from .models import ParsedResult, GenerationResult, TemplateConfig, ScopeConfig
from .validator import SmartParameterOptimizer, BestPracticesAdvisor


logger = logging.getLogger(__name__)


class YAMLGenerator:
    """YAML生成器"""
    
    def __init__(self):
        self.optimizer = SmartParameterOptimizer()
        self.advisor = BestPracticesAdvisor()
    
    def generate_yaml(self, parsed_data: ParsedResult) -> GenerationResult:
        """生成YAML配置"""
        try:
            # 1. 优化参数
            optimized_params, warnings = self.optimizer.optimize_parameters(
                parsed_data.parameters, parsed_data.scope
            )
            
            # 2. 创建基础模板
            yaml_doc = TemplateConfig.create_experiment_template(
                parsed_data.scope,
                parsed_data.target,
                parsed_data.action,
                parsed_data.description
            )
            
            # 3. 设置基本信息
            yaml_doc["metadata"]["name"] = parsed_data.name
            
            # 4. 处理参数
            experiment = yaml_doc["spec"]["experiments"][0]
            self._process_parameters(experiment, optimized_params, parsed_data.scope)
            
            # 5. 添加最佳实践建议
            best_practices = self.advisor.get_best_practices(
                parsed_data.scope, parsed_data.target, parsed_data.action
            )
            
            # 6. 生成YAML内容
            yaml_content = yaml.dump(yaml_doc, default_flow_style=False, allow_unicode=True)
            
            # 7. 添加注释
            yaml_content = self._add_comments(yaml_content, best_practices)
            
            return GenerationResult(
                success=True,
                yaml_content=yaml_content,
                warnings=warnings,
                generated_files=[]
            )
            
        except Exception as e:
            logger.error(f"生成YAML失败: {e}")
            return GenerationResult(
                success=False,
                error_message=str(e),
                warnings=warnings if 'warnings' in locals() else []
            )
    
    def _process_parameters(self, experiment: Dict[str, Any], params: Dict[str, Any], scope: str):
        """处理参数"""
        matchers = []
        flags = []
        
        # 获取作用域配置
        scope_config = ScopeConfig.get_scope_config(scope)
        required_matchers = scope_config.get("required_matchers", [])
        optional_matchers = scope_config.get("optional_matchers", [])
        
        # 分离matchers和flags
        for param_name, param_value in params.items():
            if param_name in required_matchers or param_name in optional_matchers:
                # 处理matchers
                if isinstance(param_value, list):
                    matchers.append({"name": param_name, "value": param_value})
                else:
                    matchers.append({"name": param_name, "value": [param_value]})
            else:
                # 处理flags
                flags.append({"name": param_name, "value": str(param_value)})
        
        # 添加到实验配置
        experiment["matchers"] = matchers
        experiment["flags"] = flags
    
    def _add_comments(self, yaml_content: str, best_practices: List[str]) -> str:
        """添加注释"""
        comments = []
        comments.append("# ChaosBlade YAML Configuration")
        comments.append("# Generated by ChaosBlade YAML Generator")
        comments.append("")
        
        # 添加最佳实践注释
        if best_practices:
            comments.append("# 最佳实践建议:")
            for practice in best_practices:
                comments.append(f"# {practice}")
            comments.append("")
        
        return "\n".join(comments) + "\n" + yaml_content
    
    def generate_multiple_yamls(self, parsed_data: ParsedResult, 
                              scopes: List[str]) -> List[GenerationResult]:
        """生成多个作用域的YAML"""
        results = []
        
        for scope in scopes:
            # 创建新的解析结果
            new_parsed = ParsedResult(
                name=f"{parsed_data.name}-{scope}",
                scope=scope,
                target=parsed_data.target,
                action=parsed_data.action,
                parameters=parsed_data.parameters.copy(),
                description=f"{parsed_data.description} ({scope} scope)",
                confidence=parsed_data.confidence,
                warnings=parsed_data.warnings.copy()
            )
            
            # 生成YAML
            result = self.generate_yaml(new_parsed)
            results.append(result)
        
        return results


class FileGenerator:
    """文件生成器"""
    
    def __init__(self, output_dir: str = "./generated-yamls"):
        self.output_dir = output_dir
        self.ensure_output_dir()
    
    def ensure_output_dir(self):
        """确保输出目录存在"""
        import os
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
    
    def save_yaml(self, content: str, filename: str) -> str:
        """保存YAML文件"""
        import os
        filepath = os.path.join(self.output_dir, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"YAML文件已保存: {filepath}")
        return filepath
    
    def save_multiple_yamls(self, results: List[GenerationResult], 
                           base_filename: str) -> List[str]:
        """保存多个YAML文件"""
        saved_files = []
        
        for i, result in enumerate(results):
            if result.success:
                filename = f"{base_filename}-{i+1}.yaml"
                filepath = self.save_yaml(result.yaml_content, filename)
                saved_files.append(filepath)
        
        return saved_files
    
    def generate_filename(self, scope: str, target: str, action: str) -> str:
        """生成文件名"""
        import datetime
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"{scope}-{target}-{action}-{timestamp}.yaml"


class BatchGenerator:
    """批量生成器"""
    
    def __init__(self):
        self.yaml_generator = YAMLGenerator()
        self.file_generator = FileGenerator()
    
    def generate_from_instructions(self, instructions: List[str]) -> List[GenerationResult]:
        """从指令列表批量生成"""
        from .parser import NaturalLanguageParser
        
        parser = NaturalLanguageParser()
        results = []
        
        for instruction in instructions:
            try:
                # 解析指令
                parsed_data = parser.parse_instruction(instruction)
                
                # 生成YAML
                result = self.yaml_generator.generate_yaml(parsed_data)
                
                # 保存文件
                if result.success:
                    filename = self.file_generator.generate_filename(
                        parsed_data.scope, parsed_data.target, parsed_data.action
                    )
                    filepath = self.file_generator.save_yaml(result.yaml_content, filename)
                    result.generated_files = [filepath]
                
                results.append(result)
                
            except Exception as e:
                logger.error(f"生成失败 ({instruction}): {e}")
                results.append(GenerationResult(
                    success=False,
                    error_message=str(e)
                ))
        
        return results
    
    def generate_all_scopes(self, instruction: str) -> List[GenerationResult]:
        """生成所有作用域的配置"""
        from .parser import NaturalLanguageParser
        
        parser = NaturalLanguageParser()
        parsed_data = parser.parse_instruction(instruction)
        
        # 获取所有支持的作用域
        scopes = ScopeConfig.get_all_scopes()
        
        return self.yaml_generator.generate_multiple_yamls(parsed_data, scopes)


class TemplateRenderer:
    """模板渲染器"""
    
    def __init__(self):
        self.templates = self._load_templates()
    
    def _load_templates(self) -> Dict[str, str]:
        """加载模板"""
        return {
            "node-file-add": """
apiVersion: chaosblade.io/v1alpha1
kind: ChaosBlade
metadata:
  name: {name}
  namespace: {namespace}
spec:
  experiments:
  - scope: node
    target: file
    action: add
    desc: "{description}"
    matchers:
    - name: names
      value: {names}
    flags:
    - name: filepath
      value: {filepath}
    - name: content
      value: {content}
    - name: timeout
      value: "{timeout}"
""",
            "pod-network-delay": """
apiVersion: chaosblade.io/v1alpha1
kind: ChaosBlade
metadata:
  name: {name}
  namespace: {namespace}
spec:
  experiments:
  - scope: pod
    target: network
    action: delay
    desc: "{description}"
    matchers:
    - name: names
      value: {names}
    - name: namespace
      value: {namespace}
    flags:
    - name: delay
      value: "{delay}"
    - name: interface
      value: "{interface}"
    - name: timeout
      value: "{timeout}"
"""
        }
    
    def render_template(self, template_name: str, **kwargs) -> str:
        """渲染模板"""
        template = self.templates.get(template_name)
        if not template:
            raise ValueError(f"模板 {template_name} 不存在")
        
        return template.format(**kwargs)
    
    def get_available_templates(self) -> List[str]:
        """获取可用模板列表"""
        return list(self.templates.keys())